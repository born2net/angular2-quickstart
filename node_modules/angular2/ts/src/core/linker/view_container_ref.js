import { ListWrapper } from 'angular2/src/core/facade/collection';
import { unimplemented } from 'angular2/src/core/facade/exceptions';
import { isPresent } from 'angular2/src/core/facade/lang';
import { TemplateRef } from './template_ref';
import { ViewRef, ProtoViewRef, internalView } from './view_ref';
abstract;
class ViewContainerRef {
    constructor() {
        /**
         * Returns the {@link ViewRef} for the View located in this container at the specified index.
         */
        this.abstract = get(index, number);
        /**
         * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it
         * into this container at the specified `index`.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * Returns the {@link ViewRef} for the newly created View.
         */
        this.abstract = createEmbeddedView(templateRef, TemplateRef, index ?  : number);
        /**
         * Instantiates a single {@link Component} and inserts its Host View into this container at the
         * specified `index`.
         *
         * The component is instantiated using its {@link ProtoViewRef `protoView`} which can be
         * obtained via {@link Compiler#compileInHost}.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * You can optionally specify `dynamicallyCreatedProviders`, which configure the {@link Injector}
         * that will be created for the Host View.
         *
         * Returns the {@link HostViewRef} of the Host View created for the newly instantiated Component.
         */
        this.abstract = createHostView(protoViewRef ?  : ProtoViewRef, index ?  : number, dynamicallyCreatedProviders ?  : ResolvedProvider[]);
        /**
         * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * Returns the inserted {@link ViewRef}.
         */
        this.abstract = insert(viewRef, ViewRef, index ?  : number);
        /**
         * Returns the index of the View, specified via {@link ViewRef}, within the current container or
         * `-1` if this container doesn't contain the View.
         */
        this.abstract = indexOf(viewRef, ViewRef);
        /**
         * Destroys a View attached to this container at the specified `index`.
         *
         * If `index` is not specified, the last View in the container will be removed.
         */
        this.abstract = remove(index ?  : number);
        /**
         * Use along with {@link #insert} to move a View within the current container.
         *
         * If the `index` param is omitted, the last {@link ViewRef} is detached.
         */
        this.abstract = detach(index ?  : number);
    }
    /**
     * Destroys all Views in this container.
     */
    clear() {
        for (var i = this.length - 1; i >= 0; i--) {
            this.remove(i);
        }
    }
    /**
     * Returns the number of Views currently attached to this container.
     */
    get length() { return unimplemented(); }
    ;
}
export class ViewContainerRef_ extends ViewContainerRef {
    constructor(viewManager, element) {
        super();
        this.viewManager = viewManager;
        this.element = element;
    }
    _getViews() {
        let element = this.element;
        var vc = internalView(element.parentView).viewContainers[element.boundElementIndex];
        return isPresent(vc) ? vc.views : [];
    }
    get(index) { return this._getViews()[index].ref; }
    get length() { return this._getViews().length; }
    // TODO(rado): profile and decide whether bounds checks should be added
    // to the methods below.
    createEmbeddedView(templateRef, index = -1) {
        if (index == -1)
            index = this.length;
        return this.viewManager.createEmbeddedViewInContainer(this.element, index, templateRef);
    }
    createHostView(protoViewRef = null, index = -1, dynamicallyCreatedProviders = null) {
        if (index == -1)
            index = this.length;
        return this.viewManager.createHostViewInContainer(this.element, index, protoViewRef, dynamicallyCreatedProviders);
    }
    // TODO(i): refactor insert+remove into move
    insert(viewRef, index = -1) {
        if (index == -1)
            index = this.length;
        return this.viewManager.attachViewInContainer(this.element, index, viewRef);
    }
    indexOf(viewRef) {
        return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
    }
    // TODO(i): rename to destroy
    remove(index = -1) {
        if (index == -1)
            index = this.length - 1;
        this.viewManager.destroyViewInContainer(this.element, index);
        // view is intentionally not returned to the client.
    }
    // TODO(i): refactor insert+remove into move
    detach(index = -1) {
        if (index == -1)
            index = this.length - 1;
        return this.viewManager.detachViewInContainer(this.element, index);
    }
}
//# sourceMappingURL=view_container_ref.js.map