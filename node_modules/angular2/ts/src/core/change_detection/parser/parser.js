System.register(['angular2/src/core/di/decorators', 'angular2/src/core/facade/lang', 'angular2/src/core/facade/exceptions', 'angular2/src/core/facade/collection', './lexer', 'angular2/src/core/reflection/reflection', './ast'], function(exports_1) {
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var decorators_1, lang_1, exceptions_1, collection_1, lexer_1, reflection_1, ast_1;
    var _implicitReceiver, INTERPOLATION_REGEXP, ParseException, Parser, _ParseAST, SimpleExpressionChecker;
    return {
        setters:[
            function (decorators_1_1) {
                decorators_1 = decorators_1_1;
            },
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (lexer_1_1) {
                lexer_1 = lexer_1_1;
            },
            function (reflection_1_1) {
                reflection_1 = reflection_1_1;
            },
            function (ast_1_1) {
                ast_1 = ast_1_1;
            }],
        execute: function() {
            var _implicitReceiver = new ast_1.ImplicitReceiver();
            // TODO(tbosch): Cannot make this const/final right now because of the transpiler...
            var INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
            class ParseException extends exceptions_1.BaseException {
                constructor(message, input, errLocation, ctxLocation) {
                    super(`Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`);
                }
            }
            let Parser = class {
                constructor(/** @internal */ _lexer, providedReflector = null) {
                    this._lexer = _lexer;
                    this._reflector = lang_1.isPresent(providedReflector) ? providedReflector : reflection_1.reflector;
                }
                parseAction(input, location) {
                    this._checkNoInterpolation(input, location);
                    var tokens = this._lexer.tokenize(input);
                    var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
                    return new ast_1.ASTWithSource(ast, input, location);
                }
                parseBinding(input, location) {
                    this._checkNoInterpolation(input, location);
                    var tokens = this._lexer.tokenize(input);
                    var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                    return new ast_1.ASTWithSource(ast, input, location);
                }
                parseSimpleBinding(input, location) {
                    this._checkNoInterpolation(input, location);
                    var tokens = this._lexer.tokenize(input);
                    var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
                    return new ast_1.ASTWithSource(ast, input, location);
                }
                parseTemplateBindings(input, location) {
                    var tokens = this._lexer.tokenize(input);
                    return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
                }
                parseInterpolation(input, location) {
                    var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
                    if (parts.length <= 1) {
                        return null;
                    }
                    var strings = [];
                    var expressions = [];
                    for (var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        if (i % 2 === 0) {
                            // fixed string
                            strings.push(part);
                        }
                        else if (part.trim().length > 0) {
                            var tokens = this._lexer.tokenize(part);
                            var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                            expressions.push(ast);
                        }
                        else {
                            throw new ParseException('Blank expressions are not allowed in interpolated strings', input, `at column ${this._findInterpolationErrorColumn(parts, i)} in`, location);
                        }
                    }
                    return new ast_1.ASTWithSource(new ast_1.Interpolation(strings, expressions), input, location);
                }
                wrapLiteralPrimitive(input, location) {
                    return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);
                }
                _checkNoInterpolation(input, location) {
                    var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
                    if (parts.length > 1) {
                        throw new ParseException('Got interpolation ({{}}) where expression was expected', input, `at column ${this._findInterpolationErrorColumn(parts, 1)} in`, location);
                    }
                }
                _findInterpolationErrorColumn(parts, partInErrIdx) {
                    var errLocation = '';
                    for (var j = 0; j < partInErrIdx; j++) {
                        errLocation += j % 2 === 0 ? parts[j] : `{{${parts[j]}}}`;
                    }
                    return errLocation.length;
                }
            };
            Parser = __decorate([
                decorators_1.Injectable()
            ], Parser);
            Parser = Parser;
            class _ParseAST {
                constructor(input, location, tokens, reflector, parseAction) {
                    this.input = input;
                    this.location = location;
                    this.tokens = tokens;
                    this.reflector = reflector;
                    this.parseAction = parseAction;
                    this.index = 0;
                }
                peek(offset) {
                    var i = this.index + offset;
                    return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
                }
                get next() { return this.peek(0); }
                get inputIndex() {
                    return (this.index < this.tokens.length) ? this.next.index : this.input.length;
                }
                advance() { this.index++; }
                optionalCharacter(code) {
                    if (this.next.isCharacter(code)) {
                        this.advance();
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                optionalKeywordVar() {
                    if (this.peekKeywordVar()) {
                        this.advance();
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                peekKeywordVar() { return this.next.isKeywordVar() || this.next.isOperator('#'); }
                expectCharacter(code) {
                    if (this.optionalCharacter(code))
                        return;
                    this.error(`Missing expected ${lang_1.StringWrapper.fromCharCode(code)}`);
                }
                optionalOperator(op) {
                    if (this.next.isOperator(op)) {
                        this.advance();
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                expectOperator(operator) {
                    if (this.optionalOperator(operator))
                        return;
                    this.error(`Missing expected operator ${operator}`);
                }
                expectIdentifierOrKeyword() {
                    var n = this.next;
                    if (!n.isIdentifier() && !n.isKeyword()) {
                        this.error(`Unexpected token ${n}, expected identifier or keyword`);
                    }
                    this.advance();
                    return n.toString();
                }
                expectIdentifierOrKeywordOrString() {
                    var n = this.next;
                    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
                        this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);
                    }
                    this.advance();
                    return n.toString();
                }
                parseChain() {
                    var exprs = [];
                    while (this.index < this.tokens.length) {
                        var expr = this.parsePipe();
                        exprs.push(expr);
                        if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                            if (!this.parseAction) {
                                this.error("Binding expression cannot contain chained expression");
                            }
                            while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                            } // read all semicolons
                        }
                        else if (this.index < this.tokens.length) {
                            this.error(`Unexpected token '${this.next}'`);
                        }
                    }
                    if (exprs.length == 0)
                        return new ast_1.EmptyExpr();
                    if (exprs.length == 1)
                        return exprs[0];
                    return new ast_1.Chain(exprs);
                }
                parseSimpleBinding() {
                    var ast = this.parseChain();
                    if (!SimpleExpressionChecker.check(ast)) {
                        this.error(`Simple binding expression can only contain field access and constants'`);
                    }
                    return ast;
                }
                parsePipe() {
                    var result = this.parseExpression();
                    if (this.optionalOperator("|")) {
                        if (this.parseAction) {
                            this.error("Cannot have a pipe in an action expression");
                        }
                        do {
                            var name = this.expectIdentifierOrKeyword();
                            var args = [];
                            while (this.optionalCharacter(lexer_1.$COLON)) {
                                args.push(this.parsePipe());
                            }
                            result = new ast_1.BindingPipe(result, name, args);
                        } while (this.optionalOperator("|"));
                    }
                    return result;
                }
                parseExpression() { return this.parseConditional(); }
                parseConditional() {
                    var start = this.inputIndex;
                    var result = this.parseLogicalOr();
                    if (this.optionalOperator('?')) {
                        var yes = this.parsePipe();
                        if (!this.optionalCharacter(lexer_1.$COLON)) {
                            var end = this.inputIndex;
                            var expression = this.input.substring(start, end);
                            this.error(`Conditional expression ${expression} requires all 3 expressions`);
                        }
                        var no = this.parsePipe();
                        return new ast_1.Conditional(result, yes, no);
                    }
                    else {
                        return result;
                    }
                }
                parseLogicalOr() {
                    // '||'
                    var result = this.parseLogicalAnd();
                    while (this.optionalOperator('||')) {
                        result = new ast_1.Binary('||', result, this.parseLogicalAnd());
                    }
                    return result;
                }
                parseLogicalAnd() {
                    // '&&'
                    var result = this.parseEquality();
                    while (this.optionalOperator('&&')) {
                        result = new ast_1.Binary('&&', result, this.parseEquality());
                    }
                    return result;
                }
                parseEquality() {
                    // '==','!=','===','!=='
                    var result = this.parseRelational();
                    while (true) {
                        if (this.optionalOperator('==')) {
                            result = new ast_1.Binary('==', result, this.parseRelational());
                        }
                        else if (this.optionalOperator('===')) {
                            result = new ast_1.Binary('===', result, this.parseRelational());
                        }
                        else if (this.optionalOperator('!=')) {
                            result = new ast_1.Binary('!=', result, this.parseRelational());
                        }
                        else if (this.optionalOperator('!==')) {
                            result = new ast_1.Binary('!==', result, this.parseRelational());
                        }
                        else {
                            return result;
                        }
                    }
                }
                parseRelational() {
                    // '<', '>', '<=', '>='
                    var result = this.parseAdditive();
                    while (true) {
                        if (this.optionalOperator('<')) {
                            result = new ast_1.Binary('<', result, this.parseAdditive());
                        }
                        else if (this.optionalOperator('>')) {
                            result = new ast_1.Binary('>', result, this.parseAdditive());
                        }
                        else if (this.optionalOperator('<=')) {
                            result = new ast_1.Binary('<=', result, this.parseAdditive());
                        }
                        else if (this.optionalOperator('>=')) {
                            result = new ast_1.Binary('>=', result, this.parseAdditive());
                        }
                        else {
                            return result;
                        }
                    }
                }
                parseAdditive() {
                    // '+', '-'
                    var result = this.parseMultiplicative();
                    while (true) {
                        if (this.optionalOperator('+')) {
                            result = new ast_1.Binary('+', result, this.parseMultiplicative());
                        }
                        else if (this.optionalOperator('-')) {
                            result = new ast_1.Binary('-', result, this.parseMultiplicative());
                        }
                        else {
                            return result;
                        }
                    }
                }
                parseMultiplicative() {
                    // '*', '%', '/'
                    var result = this.parsePrefix();
                    while (true) {
                        if (this.optionalOperator('*')) {
                            result = new ast_1.Binary('*', result, this.parsePrefix());
                        }
                        else if (this.optionalOperator('%')) {
                            result = new ast_1.Binary('%', result, this.parsePrefix());
                        }
                        else if (this.optionalOperator('/')) {
                            result = new ast_1.Binary('/', result, this.parsePrefix());
                        }
                        else {
                            return result;
                        }
                    }
                }
                parsePrefix() {
                    if (this.optionalOperator('+')) {
                        return this.parsePrefix();
                    }
                    else if (this.optionalOperator('-')) {
                        return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());
                    }
                    else if (this.optionalOperator('!')) {
                        return new ast_1.PrefixNot(this.parsePrefix());
                    }
                    else {
                        return this.parseCallChain();
                    }
                }
                parseCallChain() {
                    var result = this.parsePrimary();
                    while (true) {
                        if (this.optionalCharacter(lexer_1.$PERIOD)) {
                            result = this.parseAccessMemberOrMethodCall(result, false);
                        }
                        else if (this.optionalOperator('?.')) {
                            result = this.parseAccessMemberOrMethodCall(result, true);
                        }
                        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
                            var key = this.parsePipe();
                            this.expectCharacter(lexer_1.$RBRACKET);
                            if (this.optionalOperator("=")) {
                                var value = this.parseConditional();
                                result = new ast_1.KeyedWrite(result, key, value);
                            }
                            else {
                                result = new ast_1.KeyedRead(result, key);
                            }
                        }
                        else if (this.optionalCharacter(lexer_1.$LPAREN)) {
                            var args = this.parseCallArguments();
                            this.expectCharacter(lexer_1.$RPAREN);
                            result = new ast_1.FunctionCall(result, args);
                        }
                        else {
                            return result;
                        }
                    }
                }
                parsePrimary() {
                    if (this.optionalCharacter(lexer_1.$LPAREN)) {
                        let result = this.parsePipe();
                        this.expectCharacter(lexer_1.$RPAREN);
                        return result;
                    }
                    else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
                        this.advance();
                        return new ast_1.LiteralPrimitive(null);
                    }
                    else if (this.next.isKeywordTrue()) {
                        this.advance();
                        return new ast_1.LiteralPrimitive(true);
                    }
                    else if (this.next.isKeywordFalse()) {
                        this.advance();
                        return new ast_1.LiteralPrimitive(false);
                    }
                    else if (this.parseAction && this.next.isKeywordIf()) {
                        this.advance();
                        this.expectCharacter(lexer_1.$LPAREN);
                        let condition = this.parseExpression();
                        this.expectCharacter(lexer_1.$RPAREN);
                        let ifExp = this.parseExpressionOrBlock();
                        let elseExp;
                        if (this.next.isKeywordElse()) {
                            this.advance();
                            elseExp = this.parseExpressionOrBlock();
                        }
                        return new ast_1.If(condition, ifExp, elseExp);
                    }
                    else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
                        var elements = this.parseExpressionList(lexer_1.$RBRACKET);
                        this.expectCharacter(lexer_1.$RBRACKET);
                        return new ast_1.LiteralArray(elements);
                    }
                    else if (this.next.isCharacter(lexer_1.$LBRACE)) {
                        return this.parseLiteralMap();
                    }
                    else if (this.next.isIdentifier()) {
                        return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
                    }
                    else if (this.next.isNumber()) {
                        var value = this.next.toNumber();
                        this.advance();
                        return new ast_1.LiteralPrimitive(value);
                    }
                    else if (this.next.isString()) {
                        var literalValue = this.next.toString();
                        this.advance();
                        return new ast_1.LiteralPrimitive(literalValue);
                    }
                    else if (this.index >= this.tokens.length) {
                        this.error(`Unexpected end of expression: ${this.input}`);
                    }
                    else {
                        this.error(`Unexpected token ${this.next}`);
                    }
                    // error() throws, so we don't reach here.
                    throw new exceptions_1.BaseException("Fell through all cases in parsePrimary");
                }
                parseExpressionList(terminator) {
                    var result = [];
                    if (!this.next.isCharacter(terminator)) {
                        do {
                            result.push(this.parsePipe());
                        } while (this.optionalCharacter(lexer_1.$COMMA));
                    }
                    return result;
                }
                parseLiteralMap() {
                    var keys = [];
                    var values = [];
                    this.expectCharacter(lexer_1.$LBRACE);
                    if (!this.optionalCharacter(lexer_1.$RBRACE)) {
                        do {
                            var key = this.expectIdentifierOrKeywordOrString();
                            keys.push(key);
                            this.expectCharacter(lexer_1.$COLON);
                            values.push(this.parsePipe());
                        } while (this.optionalCharacter(lexer_1.$COMMA));
                        this.expectCharacter(lexer_1.$RBRACE);
                    }
                    return new ast_1.LiteralMap(keys, values);
                }
                parseAccessMemberOrMethodCall(receiver, isSafe = false) {
                    let id = this.expectIdentifierOrKeyword();
                    if (this.optionalCharacter(lexer_1.$LPAREN)) {
                        let args = this.parseCallArguments();
                        this.expectCharacter(lexer_1.$RPAREN);
                        let fn = this.reflector.method(id);
                        return isSafe ? new ast_1.SafeMethodCall(receiver, id, fn, args) :
                            new ast_1.MethodCall(receiver, id, fn, args);
                    }
                    else {
                        if (isSafe) {
                            if (this.optionalOperator("=")) {
                                this.error("The '?.' operator cannot be used in the assignment");
                            }
                            else {
                                return new ast_1.SafePropertyRead(receiver, id, this.reflector.getter(id));
                            }
                        }
                        else {
                            if (this.optionalOperator("=")) {
                                if (!this.parseAction) {
                                    this.error("Bindings cannot contain assignments");
                                }
                                let value = this.parseConditional();
                                return new ast_1.PropertyWrite(receiver, id, this.reflector.setter(id), value);
                            }
                            else {
                                return new ast_1.PropertyRead(receiver, id, this.reflector.getter(id));
                            }
                        }
                    }
                    return null;
                }
                parseCallArguments() {
                    if (this.next.isCharacter(lexer_1.$RPAREN))
                        return [];
                    var positionals = [];
                    do {
                        positionals.push(this.parsePipe());
                    } while (this.optionalCharacter(lexer_1.$COMMA));
                    return positionals;
                }
                parseExpressionOrBlock() {
                    if (this.optionalCharacter(lexer_1.$LBRACE)) {
                        let block = this.parseBlockContent();
                        this.expectCharacter(lexer_1.$RBRACE);
                        return block;
                    }
                    return this.parseExpression();
                }
                parseBlockContent() {
                    if (!this.parseAction) {
                        this.error("Binding expression cannot contain chained expression");
                    }
                    var exprs = [];
                    while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {
                        var expr = this.parseExpression();
                        exprs.push(expr);
                        if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                            while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                            } // read all semicolons
                        }
                    }
                    if (exprs.length == 0)
                        return new ast_1.EmptyExpr();
                    if (exprs.length == 1)
                        return exprs[0];
                    return new ast_1.Chain(exprs);
                }
                /**
                 * An identifier, a keyword, a string with an optional `-` inbetween.
                 */
                expectTemplateBindingKey() {
                    var result = '';
                    var operatorFound = false;
                    do {
                        result += this.expectIdentifierOrKeywordOrString();
                        operatorFound = this.optionalOperator('-');
                        if (operatorFound) {
                            result += '-';
                        }
                    } while (operatorFound);
                    return result.toString();
                }
                parseTemplateBindings() {
                    var bindings = [];
                    var prefix = null;
                    while (this.index < this.tokens.length) {
                        var keyIsVar = this.optionalKeywordVar();
                        var key = this.expectTemplateBindingKey();
                        if (!keyIsVar) {
                            if (prefix == null) {
                                prefix = key;
                            }
                            else {
                                key = prefix + '-' + key;
                            }
                        }
                        this.optionalCharacter(lexer_1.$COLON);
                        var name = null;
                        var expression = null;
                        if (keyIsVar) {
                            if (this.optionalOperator("=")) {
                                name = this.expectTemplateBindingKey();
                            }
                            else {
                                name = '\$implicit';
                            }
                        }
                        else if (this.next !== lexer_1.EOF && !this.peekKeywordVar()) {
                            var start = this.inputIndex;
                            var ast = this.parsePipe();
                            var source = this.input.substring(start, this.inputIndex);
                            expression = new ast_1.ASTWithSource(ast, source, this.location);
                        }
                        bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
                        if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {
                            this.optionalCharacter(lexer_1.$COMMA);
                        }
                    }
                    return bindings;
                }
                error(message, index = null) {
                    if (lang_1.isBlank(index))
                        index = this.index;
                    var location = (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :
                        `at the end of the expression`;
                    throw new ParseException(message, this.input, location, this.location);
                }
            }
            _ParseAST = _ParseAST;
            class SimpleExpressionChecker {
                constructor() {
                    this.simple = true;
                }
                static check(ast) {
                    var s = new SimpleExpressionChecker();
                    ast.visit(s);
                    return s.simple;
                }
                visitImplicitReceiver(ast) { }
                visitInterpolation(ast) { this.simple = false; }
                visitLiteralPrimitive(ast) { }
                visitPropertyRead(ast) { }
                visitPropertyWrite(ast) { this.simple = false; }
                visitSafePropertyRead(ast) { this.simple = false; }
                visitMethodCall(ast) { this.simple = false; }
                visitSafeMethodCall(ast) { this.simple = false; }
                visitFunctionCall(ast) { this.simple = false; }
                visitLiteralArray(ast) { this.visitAll(ast.expressions); }
                visitLiteralMap(ast) { this.visitAll(ast.values); }
                visitBinary(ast) { this.simple = false; }
                visitPrefixNot(ast) { this.simple = false; }
                visitConditional(ast) { this.simple = false; }
                visitPipe(ast) { this.simple = false; }
                visitKeyedRead(ast) { this.simple = false; }
                visitKeyedWrite(ast) { this.simple = false; }
                visitAll(asts) {
                    var res = collection_1.ListWrapper.createFixedSize(asts.length);
                    for (var i = 0; i < asts.length; ++i) {
                        res[i] = asts[i].visit(this);
                    }
                    return res;
                }
                visitChain(ast) { this.simple = false; }
                visitIf(ast) { this.simple = false; }
            }
        }
    }
});
//# sourceMappingURL=parser.js.map