System.register(['angular2/src/core/facade/lang', 'angular2/src/core/facade/collection'], function(exports_1) {
    var lang_1, collection_1;
    var _ALREADY_CHECKED_ACCESSOR, _CONTEXT_ACCESSOR, _PROP_BINDING_INDEX, _DIRECTIVES_ACCESSOR, _DISPATCHER_ACCESSOR, _LOCALS_ACCESSOR, _MODE_ACCESSOR, _PIPES_ACCESSOR, _PROTOS_ACCESSOR, CONTEXT_INDEX, _FIELD_PREFIX, _whiteSpaceRegExp, CodegenNameUtil;
    /**
     * Returns `s` with all non-identifier characters removed.
     */
    function sanitizeName(s) {
        return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
    }
    exports_1("sanitizeName", sanitizeName);
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            }],
        execute: function() {
            // The names of these fields must be kept in sync with abstract_change_detector.ts or change
            // detection will fail.
            const _ALREADY_CHECKED_ACCESSOR = "alreadyChecked";
            const _CONTEXT_ACCESSOR = "context";
            const _PROP_BINDING_INDEX = "propertyBindingIndex";
            const _DIRECTIVES_ACCESSOR = "directiveIndices";
            const _DISPATCHER_ACCESSOR = "dispatcher";
            const _LOCALS_ACCESSOR = "locals";
            const _MODE_ACCESSOR = "mode";
            const _PIPES_ACCESSOR = "pipes";
            const _PROTOS_ACCESSOR = "protos";
            // `context` is always first.
            CONTEXT_INDEX = 0;
            const _FIELD_PREFIX = 'this.';
            var _whiteSpaceRegExp = lang_1.RegExpWrapper.create("\\W", "g");
            /**
             * Class responsible for providing field and local variable names for change detector classes.
             * Also provides some convenience functions, for example, declaring variables, destroying pipes,
             * and dehydrating the detector.
             */
            class CodegenNameUtil {
                constructor(_records, _eventBindings, _directiveRecords, _utilName) {
                    this._records = _records;
                    this._eventBindings = _eventBindings;
                    this._directiveRecords = _directiveRecords;
                    this._utilName = _utilName;
                    /** @internal */
                    this._sanitizedEventNames = new collection_1.Map();
                    this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this._records.length + 1);
                    this._sanitizedNames[CONTEXT_INDEX] = _CONTEXT_ACCESSOR;
                    for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
                        this._sanitizedNames[i + 1] = sanitizeName(`${this._records[i].name}${i}`);
                    }
                    for (var ebIndex = 0; ebIndex < _eventBindings.length; ++ebIndex) {
                        var eb = _eventBindings[ebIndex];
                        var names = [_CONTEXT_ACCESSOR];
                        for (var i = 0, iLen = eb.records.length; i < iLen; ++i) {
                            names.push(sanitizeName(`${eb.records[i].name}${i}_${ebIndex}`));
                        }
                        this._sanitizedEventNames.set(eb, names);
                    }
                }
                /** @internal */
                _addFieldPrefix(name) { return `${_FIELD_PREFIX}${name}`; }
                getDispatcherName() { return this._addFieldPrefix(_DISPATCHER_ACCESSOR); }
                getPipesAccessorName() { return this._addFieldPrefix(_PIPES_ACCESSOR); }
                getProtosName() { return this._addFieldPrefix(_PROTOS_ACCESSOR); }
                getDirectivesAccessorName() { return this._addFieldPrefix(_DIRECTIVES_ACCESSOR); }
                getLocalsAccessorName() { return this._addFieldPrefix(_LOCALS_ACCESSOR); }
                getAlreadyCheckedName() { return this._addFieldPrefix(_ALREADY_CHECKED_ACCESSOR); }
                getModeName() { return this._addFieldPrefix(_MODE_ACCESSOR); }
                getPropertyBindingIndex() { return this._addFieldPrefix(_PROP_BINDING_INDEX); }
                getLocalName(idx) { return `l_${this._sanitizedNames[idx]}`; }
                getEventLocalName(eb, idx) {
                    return `l_${this._sanitizedEventNames.get(eb)[idx]}`;
                }
                getChangeName(idx) { return `c_${this._sanitizedNames[idx]}`; }
                /**
                 * Generate a statement initializing local variables used when detecting changes.
                 */
                genInitLocals() {
                    var declarations = [];
                    var assignments = [];
                    for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {
                        if (i == CONTEXT_INDEX) {
                            declarations.push(`${this.getLocalName(i)} = ${this.getFieldName(i)}`);
                        }
                        else {
                            var rec = this._records[i - 1];
                            if (rec.argumentToPureFunction) {
                                var changeName = this.getChangeName(i);
                                declarations.push(`${this.getLocalName(i)},${changeName}`);
                                assignments.push(changeName);
                            }
                            else {
                                declarations.push(`${this.getLocalName(i)}`);
                            }
                        }
                    }
                    var assignmentsCode = collection_1.ListWrapper.isEmpty(assignments) ? '' : `${assignments.join('=')} = false;`;
                    return `var ${declarations.join(',')};${assignmentsCode}`;
                }
                /**
                 * Generate a statement initializing local variables for event handlers.
                 */
                genInitEventLocals() {
                    var res = [`${this.getLocalName(CONTEXT_INDEX)} = ${this.getFieldName(CONTEXT_INDEX)}`];
                    this._sanitizedEventNames.forEach((names, eb) => {
                        for (var i = 0; i < names.length; ++i) {
                            if (i !== CONTEXT_INDEX) {
                                res.push(`${this.getEventLocalName(eb, i)}`);
                            }
                        }
                    });
                    return res.length > 1 ? `var ${res.join(',')};` : '';
                }
                getPreventDefaultAccesor() { return "preventDefault"; }
                getFieldCount() { return this._sanitizedNames.length; }
                getFieldName(idx) { return this._addFieldPrefix(this._sanitizedNames[idx]); }
                getAllFieldNames() {
                    var fieldList = [];
                    for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {
                        if (k === 0 || this._records[k - 1].shouldBeChecked()) {
                            fieldList.push(this.getFieldName(k));
                        }
                    }
                    for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
                        var rec = this._records[i];
                        if (rec.isPipeRecord()) {
                            fieldList.push(this.getPipeName(rec.selfIndex));
                        }
                    }
                    for (var j = 0, jLen = this._directiveRecords.length; j < jLen; ++j) {
                        var dRec = this._directiveRecords[j];
                        fieldList.push(this.getDirectiveName(dRec.directiveIndex));
                        if (!dRec.isDefaultChangeDetection()) {
                            fieldList.push(this.getDetectorName(dRec.directiveIndex));
                        }
                    }
                    return fieldList;
                }
                /**
                 * Generates statements which clear all fields so that the change detector is dehydrated.
                 */
                genDehydrateFields() {
                    var fields = this.getAllFieldNames();
                    collection_1.ListWrapper.removeAt(fields, CONTEXT_INDEX);
                    if (collection_1.ListWrapper.isEmpty(fields))
                        return '';
                    // At least one assignment.
                    fields.push(`${this._utilName}.uninitialized;`);
                    return fields.join(' = ');
                }
                /**
                 * Generates statements destroying all pipe variables.
                 */
                genPipeOnDestroy() {
                    return collection_1.ListWrapper.filter(this._records, (r) => { return r.isPipeRecord(); })
                        .map(r => `${this._utilName}.callPipeOnDestroy(${this.getPipeName(r.selfIndex)});`)
                        .join('\n');
                }
                getPipeName(idx) {
                    return this._addFieldPrefix(`${this._sanitizedNames[idx]}_pipe`);
                }
                getDirectiveName(d) {
                    return this._addFieldPrefix(`directive_${d.name}`);
                }
                getDetectorName(d) { return this._addFieldPrefix(`detector_${d.name}`); }
            }
            CodegenNameUtil = CodegenNameUtil;
        }
    }
});
//# sourceMappingURL=codegen_name_util.js.map