System.register(['angular2/src/core/facade/lang', 'angular2/src/core/facade/exceptions', 'angular2/src/core/facade/collection', './constants', './pipe_lifecycle_reflector', './binding_record', './directive_record'], function(exports_1) {
    var lang_1, exceptions_1, collection_1, constants_1, pipe_lifecycle_reflector_1, binding_record_1, directive_record_1;
    var WrappedValue, _wrappedValues, _wrappedIndex, SimpleChange, _simpleChangesIndex, _simpleChanges, ChangeDetectionUtil;
    function _simpleChange(previousValue, currentValue) {
        var index = _simpleChangesIndex++ % 20;
        var s = _simpleChanges[index];
        s.previousValue = previousValue;
        s.currentValue = currentValue;
        return s;
    }
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (constants_1_1) {
                constants_1 = constants_1_1;
            },
            function (pipe_lifecycle_reflector_1_1) {
                pipe_lifecycle_reflector_1 = pipe_lifecycle_reflector_1_1;
            },
            function (binding_record_1_1) {
                binding_record_1 = binding_record_1_1;
            },
            function (directive_record_1_1) {
                directive_record_1 = directive_record_1_1;
            }],
        execute: function() {
            /**
             * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
             * reference
             * has not changed.
             *
             * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
             *
             * Example:
             *
             * ```
             * if (this._latestValue === this._latestReturnedValue) {
             *    return this._latestReturnedValue;
             *  } else {
             *    this._latestReturnedValue = this._latestValue;
             *    return WrappedValue.wrap(this._latestValue); // this will force update
             *  }
             * ```
             */
            class WrappedValue {
                constructor(wrapped) {
                    this.wrapped = wrapped;
                }
                static wrap(value) {
                    var w = _wrappedValues[_wrappedIndex++ % 5];
                    w.wrapped = value;
                    return w;
                }
            }
            WrappedValue = WrappedValue;
            var _wrappedValues = [
                new WrappedValue(null),
                new WrappedValue(null),
                new WrappedValue(null),
                new WrappedValue(null),
                new WrappedValue(null)
            ];
            var _wrappedIndex = 0;
            class SimpleChange {
                constructor(previousValue, currentValue) {
                    this.previousValue = previousValue;
                    this.currentValue = currentValue;
                }
                isFirstChange() { return this.previousValue === ChangeDetectionUtil.uninitialized; }
            }
            SimpleChange = SimpleChange;
            var _simpleChangesIndex = 0;
            var _simpleChanges = [
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null),
                new SimpleChange(null, null)
            ];
            /* tslint:disable:requireParameterType */
            class ChangeDetectionUtil {
                static arrayFn0() { return []; }
                static arrayFn1(a1) { return [a1]; }
                static arrayFn2(a1, a2) { return [a1, a2]; }
                static arrayFn3(a1, a2, a3) { return [a1, a2, a3]; }
                static arrayFn4(a1, a2, a3, a4) { return [a1, a2, a3, a4]; }
                static arrayFn5(a1, a2, a3, a4, a5) { return [a1, a2, a3, a4, a5]; }
                static arrayFn6(a1, a2, a3, a4, a5, a6) { return [a1, a2, a3, a4, a5, a6]; }
                static arrayFn7(a1, a2, a3, a4, a5, a6, a7) { return [a1, a2, a3, a4, a5, a6, a7]; }
                static arrayFn8(a1, a2, a3, a4, a5, a6, a7, a8) {
                    return [a1, a2, a3, a4, a5, a6, a7, a8];
                }
                static arrayFn9(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
                }
                static operation_negate(value) { return !value; }
                static operation_add(left, right) { return left + right; }
                static operation_subtract(left, right) { return left - right; }
                static operation_multiply(left, right) { return left * right; }
                static operation_divide(left, right) { return left / right; }
                static operation_remainder(left, right) { return left % right; }
                static operation_equals(left, right) { return left == right; }
                static operation_not_equals(left, right) { return left != right; }
                static operation_identical(left, right) { return left === right; }
                static operation_not_identical(left, right) { return left !== right; }
                static operation_less_then(left, right) { return left < right; }
                static operation_greater_then(left, right) { return left > right; }
                static operation_less_or_equals_then(left, right) { return left <= right; }
                static operation_greater_or_equals_then(left, right) { return left >= right; }
                static operation_logical_and(left, right) { return left && right; }
                static operation_logical_or(left, right) { return left || right; }
                static cond(cond, trueVal, falseVal) { return cond ? trueVal : falseVal; }
                static mapFn(keys) {
                    function buildMap(values) {
                        var res = collection_1.StringMapWrapper.create();
                        for (var i = 0; i < keys.length; ++i) {
                            collection_1.StringMapWrapper.set(res, keys[i], values[i]);
                        }
                        return res;
                    }
                    switch (keys.length) {
                        case 0:
                            return () => [];
                        case 1:
                            return (a1) => buildMap([a1]);
                        case 2:
                            return (a1, a2) => buildMap([a1, a2]);
                        case 3:
                            return (a1, a2, a3) => buildMap([a1, a2, a3]);
                        case 4:
                            return (a1, a2, a3, a4) => buildMap([a1, a2, a3, a4]);
                        case 5:
                            return (a1, a2, a3, a4, a5) => buildMap([a1, a2, a3, a4, a5]);
                        case 6:
                            return (a1, a2, a3, a4, a5, a6) => buildMap([a1, a2, a3, a4, a5, a6]);
                        case 7:
                            return (a1, a2, a3, a4, a5, a6, a7) => buildMap([a1, a2, a3, a4, a5, a6, a7]);
                        case 8:
                            return (a1, a2, a3, a4, a5, a6, a7, a8) => buildMap([a1, a2, a3, a4, a5, a6, a7, a8]);
                        case 9:
                            return (a1, a2, a3, a4, a5, a6, a7, a8, a9) => buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                        default:
                            throw new exceptions_1.BaseException(`Does not support literal maps with more than 9 elements`);
                    }
                }
                static keyedAccess(obj, args) { return obj[args[0]]; }
                static unwrapValue(value) {
                    if (value instanceof WrappedValue) {
                        return value.wrapped;
                    }
                    else {
                        return value;
                    }
                }
                static changeDetectionMode(strategy) {
                    return constants_1.isDefaultChangeDetectionStrategy(strategy) ? constants_1.ChangeDetectionStrategy.CheckAlways :
                        constants_1.ChangeDetectionStrategy.CheckOnce;
                }
                static simpleChange(previousValue, currentValue) {
                    return _simpleChange(previousValue, currentValue);
                }
                static isValueBlank(value) { return lang_1.isBlank(value); }
                static s(value) { return lang_1.isPresent(value) ? `${value}` : ''; }
                static protoByIndex(protos, selfIndex) {
                    return selfIndex < 1 ?
                        null :
                        protos[selfIndex - 1]; // self index is shifted by one because of context
                }
                static callPipeOnDestroy(selectedPipe) {
                    if (pipe_lifecycle_reflector_1.implementsOnDestroy(selectedPipe.pipe)) {
                        selectedPipe.pipe.onDestroy();
                    }
                }
                static bindingTarget(mode, elementIndex, name, unit, debug) {
                    return new binding_record_1.BindingTarget(mode, elementIndex, name, unit, debug);
                }
                static directiveIndex(elementIndex, directiveIndex) {
                    return new directive_record_1.DirectiveIndex(elementIndex, directiveIndex);
                }
            }
            ChangeDetectionUtil.uninitialized = lang_1.CONST_EXPR(new Object());
            ChangeDetectionUtil = ChangeDetectionUtil;
        }
    }
});
//# sourceMappingURL=change_detection_util.js.map