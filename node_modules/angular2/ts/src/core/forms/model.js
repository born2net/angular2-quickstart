System.register(['angular2/src/core/facade/lang', 'angular2/src/core/facade/async', 'angular2/src/core/facade/collection', './validators'], function(exports_1) {
    var lang_1, async_1, collection_1, validators_1;
    var VALID, INVALID, AbstractControl, Control, ControlGroup, ControlArray;
    function isControl(control) {
        return control instanceof AbstractControl;
    }
    exports_1("isControl", isControl);
    function _find(control, path) {
        if (lang_1.isBlank(path))
            return null;
        if (!(path instanceof Array)) {
            path = path.split("/");
        }
        if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
            return null;
        return collection_1.ListWrapper.reduce(path, (v, name) => {
            if (v instanceof ControlGroup) {
                return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
            }
            else if (v instanceof ControlArray) {
                var index = name;
                return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
            }
            else {
                return null;
            }
        }, control);
    }
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (async_1_1) {
                async_1 = async_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (validators_1_1) {
                validators_1 = validators_1_1;
            }],
        execute: function() {
            /**
             * Indicates that a Control is valid, i.e. that no errors exist in the input value.
             */
            VALID = "VALID";
            /**
             * Indicates that a Control is invalid, i.e. that an error exists in the input value.
             */
            INVALID = "INVALID";
            /**
             * Omitting from external API doc as this is really an abstract internal concept.
             */
            class AbstractControl {
                constructor(validator) {
                    this.validator = validator;
                    /** @internal */
                    this._pristine = true;
                    /** @internal */
                    this._touched = false;
                }
                get value() { return this._value; }
                get status() { return this._status; }
                get valid() { return this._status === VALID; }
                get errors() { return this._errors; }
                get pristine() { return this._pristine; }
                get dirty() { return !this.pristine; }
                get touched() { return this._touched; }
                get untouched() { return !this._touched; }
                get valueChanges() { return this._valueChanges; }
                markAsTouched() { this._touched = true; }
                markAsDirty({ onlySelf } = {}) {
                    onlySelf = lang_1.normalizeBool(onlySelf);
                    this._pristine = false;
                    if (lang_1.isPresent(this._parent) && !onlySelf) {
                        this._parent.markAsDirty({ onlySelf: onlySelf });
                    }
                }
                setParent(parent) { this._parent = parent; }
                updateValidity({ onlySelf } = {}) {
                    onlySelf = lang_1.normalizeBool(onlySelf);
                    this._errors = this.validator(this);
                    this._status = lang_1.isPresent(this._errors) ? INVALID : VALID;
                    if (lang_1.isPresent(this._parent) && !onlySelf) {
                        this._parent.updateValidity({ onlySelf: onlySelf });
                    }
                }
                updateValueAndValidity({ onlySelf, emitEvent } = {}) {
                    onlySelf = lang_1.normalizeBool(onlySelf);
                    emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
                    this._updateValue();
                    this._errors = this.validator(this);
                    this._status = lang_1.isPresent(this._errors) ? INVALID : VALID;
                    if (emitEvent) {
                        async_1.ObservableWrapper.callNext(this._valueChanges, this._value);
                    }
                    if (lang_1.isPresent(this._parent) && !onlySelf) {
                        this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    }
                }
                find(path) { return _find(this, path); }
                getError(errorCode, path = null) {
                    var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
                    if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
                        return collection_1.StringMapWrapper.get(control._errors, errorCode);
                    }
                    else {
                        return null;
                    }
                }
                hasError(errorCode, path = null) {
                    return lang_1.isPresent(this.getError(errorCode, path));
                }
                /** @internal */
                _updateValue() { }
            }
            AbstractControl = AbstractControl;
            /**
             * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
             * validation state, which is determined by an optional validation function.
             *
             * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
             * with {@link ControlGroup} and {@link ControlArray}.
             *
             * # Usage
             *
             * By default, a `Control` is created for every `<input>` or other form component.
             * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
             * bound to a DOM element instead. This `Control` can be configured with a custom
             * validation function.
             *
             * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
             */
            class Control extends AbstractControl {
                constructor(value = null, validator = validators_1.Validators.nullValidator) {
                    super(validator);
                    this._value = value;
                    this.updateValidity({ onlySelf: true });
                    this._valueChanges = new async_1.EventEmitter();
                }
                /**
                 * Set the value of the control to `value`.
                 *
                 * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
                 * and not its parent component. If `emitEvent` is `true`, this change will cause a
                 * `valueChanges` event on the `Control` to be emitted. Both of these options default to
                 * `false`.
                 *
                 * If `emitModelToViewChange` is `true`, the view will be notified about the new value
                 * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
                 * specified.
                 */
                updateValue(value, { onlySelf, emitEvent, emitModelToViewChange } = {}) {
                    emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
                    this._value = value;
                    if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
                        this._onChange(this._value);
                    this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                }
                /**
                 * Register a listener for change events.
                 */
                registerOnChange(fn) { this._onChange = fn; }
            }
            Control = Control;
            /**
             * Defines a part of a form, of fixed length, that can contain other controls.
             *
             * A `ControlGroup` aggregates the values and errors of each {@link Control} in the group. Thus, if
             * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
             * changes its value, the entire group changes as well.
             *
             * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
             * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
             * controls, but is of variable length.
             *
             * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
             */
            class ControlGroup extends AbstractControl {
                constructor(controls, optionals = null, validator = validators_1.Validators.group) {
                    super(validator);
                    this.controls = controls;
                    this._optionals = lang_1.isPresent(optionals) ? optionals : {};
                    this._valueChanges = new async_1.EventEmitter();
                    this._setParentForControls();
                    this._value = this._reduceValue();
                    this.updateValidity({ onlySelf: true });
                }
                addControl(name, control) {
                    this.controls[name] = control;
                    control.setParent(this);
                }
                removeControl(name) { collection_1.StringMapWrapper.delete(this.controls, name); }
                include(controlName) {
                    collection_1.StringMapWrapper.set(this._optionals, controlName, true);
                    this.updateValueAndValidity();
                }
                exclude(controlName) {
                    collection_1.StringMapWrapper.set(this._optionals, controlName, false);
                    this.updateValueAndValidity();
                }
                contains(controlName) {
                    var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
                    return c && this._included(controlName);
                }
                /** @internal */
                _setParentForControls() {
                    collection_1.StringMapWrapper.forEach(this.controls, (control, name) => { control.setParent(this); });
                }
                /** @internal */
                _updateValue() { this._value = this._reduceValue(); }
                /** @internal */
                _reduceValue() {
                    return this._reduceChildren({}, (acc, control, name) => {
                        acc[name] = control.value;
                        return acc;
                    });
                }
                /** @internal */
                _reduceChildren(initValue, fn) {
                    var res = initValue;
                    collection_1.StringMapWrapper.forEach(this.controls, (control, name) => {
                        if (this._included(name)) {
                            res = fn(res, control, name);
                        }
                    });
                    return res;
                }
                /** @internal */
                _included(controlName) {
                    var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
                    return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
                }
            }
            ControlGroup = ControlGroup;
            /**
             * Defines a part of a form, of variable length, that can contain other controls.
             *
             * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
             * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
             * changes its value, the entire group changes as well.
             *
             * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
             * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
             * other controls, but is of fixed length.
             *
             * # Adding or removing controls
             *
             * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
             * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
             * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
             * the `ControlArray` directly, as that will result in strange and unexpected behavior such
             * as broken change detection.
             *
             * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
             */
            class ControlArray extends AbstractControl {
                constructor(controls, validator = validators_1.Validators.array) {
                    super(validator);
                    this.controls = controls;
                    this._valueChanges = new async_1.EventEmitter();
                    this._setParentForControls();
                    this._updateValue();
                    this.updateValidity({ onlySelf: true });
                }
                /**
                 * Get the {@link AbstractControl} at the given `index` in the array.
                 */
                at(index) { return this.controls[index]; }
                /**
                 * Insert a new {@link AbstractControl} at the end of the array.
                 */
                push(control) {
                    this.controls.push(control);
                    control.setParent(this);
                    this.updateValueAndValidity();
                }
                /**
                 * Insert a new {@link AbstractControl} at the given `index` in the array.
                 */
                insert(index, control) {
                    collection_1.ListWrapper.insert(this.controls, index, control);
                    control.setParent(this);
                    this.updateValueAndValidity();
                }
                /**
                 * Remove the control at the given `index` in the array.
                 */
                removeAt(index) {
                    collection_1.ListWrapper.removeAt(this.controls, index);
                    this.updateValueAndValidity();
                }
                /**
                 * Get the length of the control array.
                 */
                get length() { return this.controls.length; }
                /** @internal */
                _updateValue() { this._value = this.controls.map((control) => control.value); }
                /** @internal */
                _setParentForControls() {
                    this.controls.forEach((control) => { control.setParent(this); });
                }
            }
            ControlArray = ControlArray;
        }
    }
});
//# sourceMappingURL=model.js.map